# 软件定时器管理

## 5.1 章节介绍和范围


软件计时器用于调度功能在将来的设定时间执行，或以固定频率定期执行。由软件定时器执行的函数称为软件定时器的回调函数。

软件计时器由FreeRTOS内核实现，并受FreeRTOS内核的控制。它们不需要硬件支持，也与硬件计时器或硬件计数器无关。

请注意，根据FreeRTOS使用创新设计以确保最高效率的理念，软件计时器不会使用任何处理时间，除非软件计时器回调函数实际正在执行。

软件计时器功能是可选的。要包括软件计时器功能，请执行以下操作:
1. 将FreeRTOS源文件FreeRTOS/Source/timers.c构建为项目的一部分
2. 在FreeRTOSConfig.h中将configUSE_TIMERS设置为1。

**范围**
本章旨在让读者更好地了解以下内容：
*  软件定时器的特性与任务特性的比较。
*  RTOS后台任务。
*  计时器命令队列。
* 单次软件定时器和周期性软件定时器之间的区别。
* 如何创建、启动、重置和更改软件计时器的周期。

## 5.2 软件定时器回调函数
软件计时器回调函数被实现为C函数。它们唯一的特别之处是它们的原型，它必须返回void，并将软件计时器的句柄作为其唯一的参数。清单72演示了回调函数原型。

```c
void ATimerCallback( TimerHandle_t xTimer );
```
清单72.软件计时器回调函数原型

软件计时器回调函数自始至终执行，并以正常方式退出。它们应该保持简短，并且不能进入阻塞状态。

*注意：正如将看到的，软件计时器回调函数在启动FreeRTOS调度程序时自动创建的任务的上下文中执行。
因此，软件计时器回调函数决不能调用会导致调用任务进入阻塞状态的FreeRTOS API函数，这一点至关重要。
可以调用xQueueReceive()之类的函数，但前提是该函数的xTicksToWait参数(指定函数的阻塞时间)设置为0。
调用vTaskDelay()之类的函数是不对的，因为调用vTaskDelay()会始终将调用任务置于阻塞状态。*

## 5.3 软件定时器的属性和状态
**软件计时器的周期**
软件计时器的‘周期’是软件计时器启动和软件计时器的回调函数执行之间的时间

**单次计时器和自动重新加载计时器**
有两种类型的软件计时器：
1. 单次计时器 
一旦启动，一次性定时器将只执行其回调函数一次。一次性计时器可以手动重新启动，但不会自行重新启动。
2. 自动重新加载计时器
一旦启动，自动重新加载计时器将在每次到期时重新启动，从而定期执行其回调函数。

<img src = https://github.com/VulcanLIU/Mastering-the-FreeRTOS-Real-Time-Kernel-CN/blob/master/.gitbook/assets/Figure%2038.png>

**图38一次性软件计时器和自动重新加载软件计时器之间的行为差异**

## 5.4 软件定时器的上下文

## 5.5 创建和开始一个软件定时器

## 5.6 定时器ID

## 5.7 更改定时器的周期

## 5.8 重置一个定时器